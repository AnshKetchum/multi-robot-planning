/**
 * Display encoder measurements from the wheels of the
 * <a href="https://www.pololu.com/docs/0J86">Pololu 3pi+ 2040 robot</a>.
 * @author Abhi Gundrala
 * @author Edward A. Lee
 */
 target C {
    platform: {
      name: "rp2040",
      board: "pololu_3pi_2040_robot"
    },
    single-threaded: true
  }
  
  import Display from "lib/Display.lf"
  import Encoders from "lib/Encoders.lf"
  import GyroAngle from "lib/IMU.lf"
  import Motors from "lib/Motors.lf"
  preamble {=
    #include <math.h>
    static float start_angle;
    static float start_dist;
    static float curr_left_power;
    static float curr_right_power;
  =}
reactor AngleToDistance {
    e = new Encoders()
    output left_distance:float
    output right_distance:float
    timer t(0, 1 s)

    reaction(t) -> e.trigger {=
        lf_set(e.trigger, true);
      =}
    reaction(e.left) -> left_distance {=
        lf_set(left_distance, (3.175*M_PI*e.left->value) / 360);
    =} 
    reaction(e.right) -> right_distance {=
        lf_set(right_distance, (3.175*M_PI*e.right->value) / 360);
    =} 

  }

reactor Robot {
  input drive: bool      // Toggle mode.
  input left_motor_speed: float  // Notify of current motor speed.
  input right_motor_speed: float
  gyro = new GyroAngle()
  a_to_d = new AngleToDistance()
  motors = new Motors()
  timer ti(0, 1 ms)
  output notify0: string
  output notify1: string
  input count: int

  reaction(startup) -> motors.left_power, motors.right_power{=
    lf_set(motors.left_power, 0.1f);
    lf_set(motors.right_power, 0.1f);
    curr_left_power = 0.1f;
    curr_right_power = 0.1f;
  =}

  initial mode DRIVING {
    reaction(ti) -> gyro.trigger, motors.left_power, motors.right_power, notify0, notify1 {=
        lf_set(gyro.trigger, true);
        static char buf0[17];
        snprintf(buf0, 17, "left: %f", curr_left_power);
        lf_set(notify0, buf0);
        static char buf1[17];
        snprintf(buf1, 17, "right: %f", curr_right_power);
        lf_set(notify1, buf1);
    =}
    reaction(a_to_d.left_distance, a_to_d.right_distance) -> reset(TURNING), motors.left_power, motors.right_power, gyro.trigger  {=
      if (a_to_d.left_distance->value - start_dist> 50) {
        count++;
        lf_set_mode(TURNING);
        lf_set(motors.left_power, 0.1f);
        lf_set(motors.right_power, -0.1f);
      }
    =}
  }
  
  mode TURNING {
    reaction(ti) -> gyro.trigger{=
        lf_set(gyro.trigger, true);
    =}
    reaction(gyro.z, a_to_d.left_distance) -> reset(DRIVING), motors.left_power, motors.right_power {=
    //   static char buf[17];
    //   snprintf(buf, 17, "angle: %f, tot: %f", start_angle - gyro.z->value );
    //   lf_set(notify, buf);
      if (start_angle - gyro.z->value > 90) {
        if (count >= 4) {
            curr_left_power += 0.1f;
            curr_right_power += 0.1f;
            count = 0;
        }
        lf_set_mode(DRIVING);
        lf_set(motors.left_power, 0.1f);
        lf_set(motors.right_power, 0.1f);
        start_angle = gyro.z->value;
        start_dist = a_to_d.left_distance->value;
      }
    =}
  }
}

main reactor {
  robot = new Robot()
  display = new Display()

  robot.notify0 -> display.line0
  robot.notify1 -> display.line1
}
