/**
 * Template for robot driving lab exercises. This template just periodically switches between a
 * STOPPED and a DRIVING mode, updating the LCD display on each change of mode.
 */
 target C {
    platform: {
      name: "rp2040",
      board: "pololu_3pi_2040_robot"
    },
    single-threaded: true
  }
  
  import Display from "lib/Display.lf"
  import Motors from "lib/Motors.lf"
  import AngleToDistance from "RobotSquareSolution.lf"
  import Encoders from "lib/Encoders.lf"
  import GyroAngle from "lib/IMU.lf"
  
  preamble {=
    #include <stdio.h>
    #include "pico/stdlib.h"
    #include "hardware/adc.h"
    #include <math.h>
    #define IR_1 26
    #define IR_LEFT 23
    #define IR_RIGHT 16
    static float start_angle;
    static float start_dist;
  =}
  
  reactor IRSensorReader {
    output IR_1_out: uint16_t
    output IR_LEFT_out: bool
    output IR_RIGHT_out: bool
    output notify1: string  // ADC Reading

    timer sampleIRs(0, 10msec)   //on-board ADCs sample at 500kHz, but we will sample slower to avoid jerky movements
    reaction(startup) {=
    stdio_init_all();
        gpio_init(IR_1);
        gpio_disable_pulls(IR_1);
        gpio_set_function(IR_1, GPIO_FUNC_NULL);
        hw_clear_bits(&padsbank0_hw->io[IR_1], PADS_BANK0_GPIO0_IE_BITS);
        adc_init();
        adc_gpio_init(IR_1);
        gpio_init(IR_LEFT);
        gpio_set_dir(IR_LEFT, GPIO_IN);
        gpio_init(IR_RIGHT);
        gpio_set_dir(IR_RIGHT, GPIO_IN);
    =}
    
    reaction(sampleIRs) -> IR_1_out {=
        adc_select_input(0);
        uint16_t ir_1_adc = adc_read();
       lf_set(IR_1_out, ir_1_adc);
      //  static char buf0[17];    
      //   snprintf(buf0, 17, "A: %d", ir_1_adc);
      //   lf_set(notify1, buf0); 
    //    lf_set(notify1, "DEBUG");  
    //lf_set(IR_1_out, 100);
    =}
    reaction(sampleIRs) -> IR_LEFT_out {=
      uint32_t mask = 1ul << IR_LEFT;
      lf_set(IR_LEFT_out, sio_hw->gpio_in & mask);
    =}
    reaction(sampleIRs) -> IR_RIGHT_out {=
      uint32_t mask = 1ul << IR_RIGHT;
      lf_set(IR_RIGHT_out, sio_hw->gpio_in & mask);
    =}
  }

  reactor RobotLineFollower {
    input avoidReduceSpeed: bool
    input avoidGoAround: bool
    input IR_1_val: uint16_t // Line Following Sensor Value
    input IR_LEFT_val: bool
    input IR_RIGHT_val: bool
    output notify1: string  // ADC Reading
    output notify2: string // Left Motor Power
    output notify3: string // Right Motor Power
    output notify4: string // LR Sensors
    motors = new Motors()
    // IR = new IR()
    reaction(startup) -> notify1 {=
      lf_set(notify1, "INIT");
      lf_set(avoidGoAround, false);
      lf_set(avoidReduceSpeed, false);
      
    =}
    // notify2, notify3, motors.left_power, motors.right_power
    initial mode FOLLOWING {
      reaction(IR_1_val, IR_LEFT_val, IR_RIGHT_val) -> notify1, notify2, notify3, notify4, motors.left_power, motors.right_power {=
            
            int median_IR_val = 500;
            float P = 0.025/350.0*3;
            int real_IR_val = IR_1_val->value;
            float left_motor_power = 0.1+(real_IR_val-median_IR_val)*P;
            float right_motor_power = 0.1-(real_IR_val-median_IR_val)*P;

            lf_set(motors.left_power, left_motor_power);
            lf_set(motors.right_power, right_motor_power);

            static char buf0[17];
            static char buf1[17];
            static char buf2[17];
            static char buf3[17];
            snprintf(buf0, 17, "A: %d", real_IR_val);
            lf_set(notify1, buf0);  
            snprintf(buf1, 17, "left: %f", left_motor_power);
            lf_set(notify2, buf1);  
            snprintf(buf2, 17, "right: %f", right_motor_power);
            lf_set(notify3, buf2);
            snprintf(buf3, 17, "l: %d, r: %d", IR_LEFT_val->value, IR_RIGHT_val->value);
            lf_set(notify4, buf3);
      =}
      reaction(avoidReduceSpeed) -> motors.left_power, motors.right_power {=
        if (avoidReduceSpeed->value) {
          lf_set(motors.left_power, 0.15f);
          lf_set(motors.right_power, 0.15f);
        }
        else {
          lf_set(motors.left_power, 0.3f);
          lf_set(motors.right_power, 0.3f);
        }
      =}
      reaction(avoidGoAround) -> reset(AVOID_GO_AROUND), motors.left_power, motors.right_power {=
         lf_set(motors.left_power, 0.2f);
         lf_set(motors.right_power, -0.2f);
         lf_set_mode(AVOID_GO_AROUND);
      =}
       
      }

    mode AVOID_GO_AROUND {
      timer right_turn(250msec);
      timer straight1(0);
      timer left_turn(0);
      timer straight2(0);
      timer left_turn2(0);
      timer reorient(0);

      reaction(reset) {=
        lf_schedule(right_turn);
      =}
      reaction(right_turn) -> motors.left_power, motors.right_power {=
        lf_set(motors.left_power, 0.2f);
        lf_set(motors.right_power, 0.2f);
        lf_schedule(straight1, 250msec);
      =}
      reaction(straight1) -> motors.left_power, motors.right_power {=
        lf_set(motors.left_power, -0.2f);
        lf_set(motors.right_power, 0.2f);
        lf_schedule(left_turn, 250msec);
      =}
      reaction(left_turn) -> motors.left_power, motors.right_power {=
        lf_set(motors.left_power, 0.2f);
        lf_set(motors.right_power, 0.2f);
        lf_schedule(straight2, 1sec);
      =}
      reaction(straight2) -> motors.left_power, motors.right_power {=
        lf_set(motors.left_power, -0.2f);
        lf_set(motors.right_power, 0.2f);
        lf_schedule(left_turn2, 250msec);
      =}
      reaction(left_turn2) -> motors.left_power, motors.right_power {=
        lf_set(motors.left_power, 0.2f);
        lf_set(motors.right_power, 0.2f);
      =}

      reaction(IR_1_val, IR_LEFT_val, IR_RIGHT_val) -> reset(FOLLOWING), motors.left_power, motors.right_power {=
        if (IR_1_val->value < 180 && IR_LEFT_val->value && IR_RIGHT_val->value) {
          lf_set_mode(FOLLOWING);
          lf_set(avoidGoAround, false);
        }

      =}
    }
      

  }
  
  main reactor {
    timer t(0, 50msec)
    timer testAvoidReduceSpeed(0, 3sec)
    robot = new RobotLineFollower()
    IRSensor = new IRSensorReader()
    display = new Display()
    a_to_d = new AngleToDistance()
    IRSensor.IR_1_out -> robot.IR_1_val
    IRSensor.IR_LEFT_out -> robot.IR_LEFT_val
    IRSensor.IR_RIGHT_out -> robot.IR_RIGHT_val
    robot.notify1 -> display.line0
    robot.notify2 -> display.line1
    robot.notify3 -> display.line2
    robot.notify4 -> display.line3
    reaction(t) -> robot.avoidReduceSpeed {=
      lf_set(robot.avoidReduceSpeed, self->avoidReduceSpeed);
      // Toggle the drive state variable for next time.
      self->avoidReduceSpeed = !self->avoidReduceSpeed;
    =}
  
    // reaction(t) -> robot.drive, display.line0, display.line1 {=
    //   //lf_set(robot.drive, self->drive);
    //   lf_set(display.line0, "HELP"); 
    // =}

    // reaction(t) -> display.line0 {=
    // //lf_set(robot.drive, self->drive);
    //     lf_set(display.line0, "HELP"); 
    // =}
  }
  
  